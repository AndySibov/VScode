geom_density()
dev.off()
flights %>%
mutate(mph = distance / (air_time / 60)) %>%
ggplot(aes(x = mph)) +
geom_density()
#dependencies
# Git HUB connectie naar private repository configureren voor csv, png en pdf data bronnen
repos <- "https://raw.githubusercontent.com/AndySibov/devise/main/"
# tijdelijke token om de repos te kunnen betreden
token <- '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'
# Function to get files from GitHub and return their contents
load_git_files <- function(repos, filenames, token = NULL, invisible = TRUE, csv_delimiter = NULL) {
#standaard delimiter instellen
if(is.null(csv_delimiter)) csv_delimiter <- ';'
# Functie om verschillende files te kunnen lezen
read_common_file <- function(file_path, delimit = csv_delimiter) {
file_ext <- file_ext(file_path)
# Switch op file extension
switch(file_ext,
csv = read_delim(file_path, delim = delimit),   # Use separator if provided
tsv = read_delim(file_path),
rds = read_rds(file_path),
str_c(file_ext, ' is not supported')
)
}
# Functie om 1 file te kunnen lezen
process_file <- function(filename) {
# Encoden URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Opslaan in een tijdelijke folder
temp_file <- tempfile(fileext = str_c(".", sub(".*\\.", "", filename)))
writeBin(content(request, "raw"), temp_file)
# Inlezen van de tijdelijk opgeslagen file
return(read_common_file(temp_file))
}
# Map the process file functie op de filenames argument
if(invisible) {
results <- map(filenames, process_file) %>% invisible() %>% suppressMessages()
} else {
results <- map(filenames, process_file)
}
names(results) <- filenames
# Unlisten alse er maar 1 file is
if (length(filenames) == 1) {
return(results[[1]])
} else {
return(results)
}
}
# Functie om files op te slaan van GitHub naar een toegekende locatie
save_git_files <- function(repos, filenames, token = NULL, save_dir = tempdir()) {
# Check of de directory bestaat, ander aanmaken
if (!dir.exists(save_dir)) {
dir.create(save_dir, recursive = TRUE)
}
# Functie om 1 file te kunnen uitlezen
process_file <- function(filename) {
# Encode URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Check of the GET request goed is gegaan
if (status_code(request) == 200) {
# Opslaan van de file met de originele naam in de aangegeven directory
save_path <- file.path(save_dir, filename)
writeBin(content(request, "raw"), save_path)
message("File saved to: ", save_path)
} else {
stop("Failed to download file. HTTP status code: ", status_code(request))
}
}
# map de functie over de filenames
walk(filenames, process_file)
}
#functie om packages te installeren als ze nog niet zijn geinstalleerd
check_and_install_packages <- function(packages){
# index van niet geinstalleerde packes vinden
logical_index <- unlist(lapply(packages, function(x)requireNamespace(x, quietly = TRUE)))
#filter de lijst
uninstalled <- packages[!logical_index]
#installeer
if(length(uninstalled)>0){
install.packages(uninstalled)
}
}
#benodigde packages
pkgs <- c('tidyverse', 'readr', 'forcats', 'ggplot2', 'sf', 'cbsodataR', 'stringr', 'rlang','viridisLite', 'httr', 'RColorBrewer', 'purrr', 'readr', 'tools', 'scales')
# exe
check_and_install_packages(pkgs)
library(tidyverse)
library(readr)
library(forcats)
library(ggplot2)
library(sf)
library(cbsodataR)
library(stringr)
library(rlang)
library(viridisLite)
library(httr)
library(knitr)
library(RColorBrewer)
library(purrr)
library(readr)
library(tools)
library(scales)
chart_path <- tempdir()
chart_name <- "process_flowchart.png"
chart_filepath <- file.path(chart_path, chart_name)
save_git_files(repos = repos, filenames = chart_name, save_dir = chart_path, token = token)
#dependencies
# Git HUB connectie naar private repository configureren voor csv, png en pdf data bronnen
repos <- "https://raw.githubusercontent.com/AndySibov/devise/main/"
# tijdelijke token om de repos te kunnen betreden
token <- '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'
# Function to get files from GitHub and return their contents
load_git_files <- function(repos, filenames, token = NULL, invisible = TRUE, csv_delimiter = NULL) {
#standaard delimiter instellen
if(is.null(csv_delimiter)) csv_delimiter <- ';'
# Functie om verschillende files te kunnen lezen
read_common_file <- function(file_path, delimit = csv_delimiter) {
file_ext <- file_ext(file_path)
# Switch op file extension
switch(file_ext,
csv = read_delim(file_path, delim = delimit),   # Use separator if provided
tsv = read_delim(file_path),
rds = read_rds(file_path),
str_c(file_ext, ' is not supported')
)
}
# Functie om 1 file te kunnen lezen
process_file <- function(filename) {
# Encoden URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Opslaan in een tijdelijke folder
temp_file <- tempfile(fileext = str_c(".", sub(".*\\.", "", filename)))
writeBin(content(request, "raw"), temp_file)
# Inlezen van de tijdelijk opgeslagen file
return(read_common_file(temp_file))
}
# Map the process file functie op de filenames argument
if(invisible) {
results <- map(filenames, process_file) %>% invisible() %>% suppressMessages()
} else {
results <- map(filenames, process_file)
}
names(results) <- filenames
# Unlisten alse er maar 1 file is
if (length(filenames) == 1) {
return(results[[1]])
} else {
return(results)
}
}
# Functie om files op te slaan van GitHub naar een toegekende locatie
save_git_files <- function(repos, filenames, token = NULL, save_dir = tempdir()) {
# Check of de directory bestaat, ander aanmaken
if (!dir.exists(save_dir)) {
dir.create(save_dir, recursive = TRUE)
}
# Functie om 1 file te kunnen uitlezen
process_file <- function(filename) {
# Encode URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Check of the GET request goed is gegaan
if (status_code(request) == 200) {
# Opslaan van de file met de originele naam in de aangegeven directory
save_path <- file.path(save_dir, filename)
writeBin(content(request, "raw"), save_path)
message("File saved to: ", save_path)
} else {
stop("Failed to download file. HTTP status code: ", status_code(request))
}
}
# map de functie over de filenames
walk(filenames, process_file)
}
#functie om packages te installeren als ze nog niet zijn geinstalleerd
check_and_install_packages <- function(packages){
# index van niet geinstalleerde packes vinden
logical_index <- unlist(lapply(packages, function(x)requireNamespace(x, quietly = TRUE)))
#filter de lijst
uninstalled <- packages[!logical_index]
#installeer
if(length(uninstalled)>0){
install.packages(uninstalled)
}
}
#benodigde packages
pkgs <- c('tidyverse', 'readr', 'forcats', 'ggplot2', 'sf', 'cbsodataR', 'stringr', 'rlang','viridisLite', 'httr', 'RColorBrewer', 'purrr', 'readr', 'tools', 'scales')
# exe
check_and_install_packages(pkgs)
library(tidyverse)
library(readr)
library(forcats)
library(ggplot2)
library(sf)
library(cbsodataR)
library(stringr)
library(rlang)
library(viridisLite)
library(httr)
library(knitr)
library(RColorBrewer)
library(purrr)
library(readr)
library(tools)
library(scales)
# zorgen dat messages en warning niet in de knit komen
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
chart_path <- tempdir()
chart_name <- "process_flowchart.png"
chart_filepath <- file.path(chart_path, chart_name)
save_git_files(repos = repos, filenames = chart_name, save_dir = chart_path, token = token)
save_git_files(repos = repos, filenames = chart_name, save_dir = chart_path, token = token)
save_git_files(repos = repos, filenames = chart_name, save_dir = chart_path)
#dependencies
# Git HUB connectie naar private repository configureren voor csv, png en pdf data bronnen
repos <- "https://raw.githubusercontent.com/AndySibov/devise/main/"
# tijdelijke token om de repos te kunnen betreden
token <- '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'
# Function to get files from GitHub and return their contents
load_git_files <- function(repos, filenames, token = NULL, invisible = TRUE, csv_delimiter = NULL) {
#standaard delimiter instellen
if(is.null(csv_delimiter)) csv_delimiter <- ';'
# Functie om verschillende files te kunnen lezen
read_common_file <- function(file_path, delimit = csv_delimiter) {
file_ext <- file_ext(file_path)
# Switch op file extension
switch(file_ext,
csv = read_delim(file_path, delim = delimit),   # Use separator if provided
tsv = read_delim(file_path),
rds = read_rds(file_path),
str_c(file_ext, ' is not supported')
)
}
# Functie om 1 file te kunnen lezen
process_file <- function(filename) {
# Encoden URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Opslaan in een tijdelijke folder
temp_file <- tempfile(fileext = str_c(".", sub(".*\\.", "", filename)))
writeBin(content(request, "raw"), temp_file)
# Inlezen van de tijdelijk opgeslagen file
return(read_common_file(temp_file))
}
# Map the process file functie op de filenames argument
if(invisible) {
results <- map(filenames, process_file) %>% invisible() %>% suppressMessages()
} else {
results <- map(filenames, process_file)
}
names(results) <- filenames
# Unlisten alse er maar 1 file is
if (length(filenames) == 1) {
return(results[[1]])
} else {
return(results)
}
}
# Functie om files op te slaan van GitHub naar een toegekende locatie
save_git_files <- function(repos, filenames, token = NULL, save_dir = tempdir()) {
# Check of de directory bestaat, ander aanmaken
if (!dir.exists(save_dir)) {
dir.create(save_dir, recursive = TRUE)
}
# Functie om 1 file te kunnen uitlezen
process_file <- function(filename) {
# Encode URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Check of the GET request goed is gegaan
if (status_code(request) == 200) {
# Opslaan van de file met de originele naam in de aangegeven directory
save_path <- file.path(save_dir, filename)
writeBin(content(request, "raw"), save_path)
message("File saved to: ", save_path)
} else {
stop("Failed to download file. HTTP status code: ", status_code(request))
}
}
# map de functie over de filenames
walk(filenames, process_file)
}
#functie om packages te installeren als ze nog niet zijn geinstalleerd
check_and_install_packages <- function(packages){
# index van niet geinstalleerde packes vinden
logical_index <- unlist(lapply(packages, function(x)requireNamespace(x, quietly = TRUE)))
#filter de lijst
uninstalled <- packages[!logical_index]
#installeer
if(length(uninstalled)>0){
install.packages(uninstalled)
}
}
#benodigde packages
pkgs <- c('tidyverse', 'readr', 'forcats', 'ggplot2', 'sf', 'cbsodataR', 'stringr', 'rlang','viridisLite', 'httr', 'RColorBrewer', 'purrr', 'readr', 'tools', 'scales')
# exe
check_and_install_packages(pkgs)
library(tidyverse)
library(readr)
library(forcats)
library(ggplot2)
library(sf)
library(cbsodataR)
library(stringr)
library(rlang)
library(viridisLite)
library(httr)
library(knitr)
library(RColorBrewer)
library(purrr)
library(readr)
library(tools)
library(scales)
chart_path <- tempdir()
chart_name <- "process_flowchart.png"
chart_filepath <- file.path(chart_path, chart_name)
save_git_files(repos = repos, filenames = chart_name, save_dir = chart_path, token = token)
#render de chart
include_graphics(chart_filepath)
# opschonen: negatieve waarde op NA zetten; data uit colnames (dagdeel en jaar) formateren;  en labels toevoegen.
data <- rawdata%>%
#transponeren
pivot_longer(cols = -id, names_to = 'dagdeel_jaar', values_to = 'aanrijtijd')%>%
#dageel en jaar uit elkaar halen
separate('dagdeel_jaar', into = c('dagdeel', 'jaar'), sep = "_")%>%
#labels formateren
mutate(
dagdeel =
as.character(
fct_recode(dagdeel,
avond = 'a',
dag = 'd',
nacht = 'n')),
jaar =
as.numeric(str_c('20',jaar))
)%>%
#voeg labels toe
left_join(id_labels) %>%
rename(Provincie = 'region')
scale_growth <- function(x) x/x[1]*100 - 100
rmarkdown::pandoc_available
rmarkdown::pandoc_available()
?pandoc_available()
install.packages('rmarkdown')
install.packages("rmarkdown")
library(rmarkdown, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages("rmarkdown", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
library(xfun, lib.loc = "/Library/Frameworks/R.framework/Versions/4.2/Resources/library")
install.packages('xfun')
install.packages("xfun")
#dependencies
install.packages('xfun')
# Git HUB connectie naar private repository configureren voor csv, png en pdf data bronnen
repos <- "https://raw.githubusercontent.com/AndySibov/devise/main/"
# tijdelijke token om de repos te kunnen betreden
token <- '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'
# Function to get files from GitHub and return their contents
load_git_files <- function(repos, filenames, token = NULL, invisible = TRUE, csv_delimiter = NULL) {
#standaard delimiter instellen
if(is.null(csv_delimiter)) csv_delimiter <- ';'
# Functie om verschillende files te kunnen lezen
read_common_file <- function(file_path, delimit = csv_delimiter) {
file_ext <- file_ext(file_path)
# Switch op file extension
switch(file_ext,
csv = read_delim(file_path, delim = delimit),   # Use separator if provided
tsv = read_delim(file_path),
rds = read_rds(file_path),
str_c(file_ext, ' is not supported')
)
}
# Functie om 1 file te kunnen lezen
process_file <- function(filename) {
# Encoden URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Opslaan in een tijdelijke folder
temp_file <- tempfile(fileext = str_c(".", sub(".*\\.", "", filename)))
writeBin(content(request, "raw"), temp_file)
# Inlezen van de tijdelijk opgeslagen file
return(read_common_file(temp_file))
}
# Map the process file functie op de filenames argument
if(invisible) {
results <- map(filenames, process_file) %>% invisible() %>% suppressMessages()
} else {
results <- map(filenames, process_file)
}
names(results) <- filenames
# Unlisten alse er maar 1 file is
if (length(filenames) == 1) {
return(results[[1]])
} else {
return(results)
}
}
# Functie om files op te slaan van GitHub naar een toegekende locatie
save_git_files <- function(repos, filenames, token = NULL, save_dir = tempdir()) {
# Check of de directory bestaat, ander aanmaken
if (!dir.exists(save_dir)) {
dir.create(save_dir, recursive = TRUE)
}
# Functie om 1 file te kunnen uitlezen
process_file <- function(filename) {
# Encode URL
encoded_filename <- URLencode(filename)
# Defineer URL
url <- str_c(repos, encoded_filename)
# GET request
if (!is.null(token)) {
request <- GET(url, add_headers(Authorization = paste("token", token)))
} else {
request <- GET(url)
}
# Check of the GET request goed is gegaan
if (status_code(request) == 200) {
# Opslaan van de file met de originele naam in de aangegeven directory
save_path <- file.path(save_dir, filename)
writeBin(content(request, "raw"), save_path)
message("File saved to: ", save_path)
} else {
stop("Failed to download file. HTTP status code: ", status_code(request))
}
}
# map de functie over de filenames
walk(filenames, process_file)
}
#functie om packages te installeren als ze nog niet zijn geinstalleerd
check_and_install_packages <- function(packages){
# index van niet geinstalleerde packes vinden
logical_index <- unlist(lapply(packages, function(x)requireNamespace(x, quietly = TRUE)))
#filter de lijst
uninstalled <- packages[!logical_index]
#installeer
if(length(uninstalled)>0){
install.packages(uninstalled)
}
}
#benodigde packages
pkgs <- c('tidyverse', 'readr', 'forcats', 'ggplot2', 'sf', 'cbsodataR', 'stringr', 'rlang','viridisLite', 'httr', 'RColorBrewer', 'purrr', 'readr', 'tools', 'scales')
# exe
check_and_install_packages(pkgs)
library(tidyverse)
library(readr)
library(forcats)
library(ggplot2)
library(sf)
library(cbsodataR)
library(stringr)
library(rlang)
library(viridisLite)
library(httr)
library(knitr)
install.packages("xfun")
library(knitr)
install.packages('xfun')
rmarkdown::pandoc_available()
?render()
